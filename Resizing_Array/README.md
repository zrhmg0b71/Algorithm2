# Resizing Array

## 1. Array VS Resizing Array
### Array (기본 배열)
- 하나 이상 연관된 데이터 저장 시 배열 사용
- 초기화할 때 크기 지정해주면 그 크기로 고정됨
- 단점 : 데이터 크기 미리 알기 어려운 상황이 많아서 미리 크기 지정하기 불편

### Resizing Array
- 저장된 데이터 양에 따라 크기 자동 조정하는 자료구조
- 기본 배열처럼 index로 원소 접근 가능
    - ex) C++의 vector, Python에 List, Java에 ArrayList
- 사용자는 크기 걱정할 필요 없이 데이터 추가, 삭제 가능해 편리함

## 2. 구현 방법
### 1> Linked List
데이터 추가 : 새 노드 추가
### 2> 기본 배열 사용
미리 크기 N의 배열 준비해두고 더 많은 공간 필요 시 더 큰 배열(2N 크기) 만들어서 기존 데이터 복사 (초기화 & Doubling)

## 3. Linked List VS 기본 배열 사용
### Linked List 사용 구현
- 메모리 사용량 : 노드가 메모리 여러 곳에 흩어져 있음 → 다음 노드 reference(pointer) 저장할 추가 공간 필요
- 메모리 간 전송 속도 : 디스크 → 메모리 → 캐시 읽을 때 다 흩어져있어서 읽고 쓰는 시간 오래 걸림
- 임의 위치 원소 접근 : reference 따라 이동 → ~N
- 마지막에 새 원소 추가 : 마지막 위치의 reference 있으면 ~1
- 임의 위치 원소 추가/삭제 : 추가, 삭제 위치 찾는 데에 ~N 시간 BUT 위치 찾았으면 추가/삭제에는 ~1시간

### 기본 배열 사용 구현
- 메모리 사용량 : 연속된 메모리 사용 → 다음 노드 위치 명확 → reference 저장할 필요 X
- 메모리 간 전송 속도 : 디스크 → 메모리 → 캐시 읽을 때 모든 노드가 메모리에서 인접해 있어서 같은 블록에 속하기 때문에 읽는 시간 빠름
- 임의 위치 원소 접근 : 인덱스로 접근 → ~1
- 마지막에 새 원소 추가 : 평균 ~1 시간. 가끔 새 배열 만들고 기존 원소 복사할 때 제외
- 임의 위치 원소 추가/삭제 : 추가, 삭제 위치는 index로 바로 찾음 (~1) BUT 뒤 원소 한 칸씩 이동시키는 데 ~N시간

## 4. 기본 배열 사용한 Resizing Array에서의 Resize 비용
: 원소 추가 한 번당 상수 시간 (~1)
- 새 배열 만드는 비용 (메모리 할당) : ~상수 시간
- 기존 원소 복사 비용 : 원소 개수에 비례
    - resizing 비용은 매번 일어나는 것이 아닌 가끔 일어나기 때문에 평균 비용 계산할 필요 O
- N개 원소 추가하는 비용 : 1 + 2 + 4 + ... + 2<sup>k</sup> (N/2 < 2<sup>k</sup> <= N, 즉 2<sup>k</sup>는 N에 비례)
    - 원소 추가 한 번당 평균 비용 : N / N = ~1 ⇒ 가끔 resize 일어나 큰 비용이 들지만 평균은 상수 비용 !!

## 5. 기본 배열 사용한 Resizing Array에서의 삭제 - 배열 크기 축소
- 원소 추가 : 가득 차면 2N 크기 배열 만들어 기존 원소 복사
- 원소 삭제 : 원소 수가 N/4개 되면 N/2 크기 배열 만들어 기존 원소 복사 → 불필요한 메모리 낭비 줄임
    - Thrashing(반복해 같은 곳 때림) 현상 방지하기 위해 resize 임계치를 N/2가 아닌 N/4로 설정
- pop(index) : index 위치의 원소 삭제(하며 반환)하는 기능
- 구현 방법
    - 삭제한 위치 바로 뒤 원소 ~ 마지막 원소를 ((index + 1) ~ (N - 1) 위치 원소를) 한 칸 씩 앞으로 옮겨 담음
    - 원소가 연속으로 담겨 있으야 index로 편리하게 접근 & 빈 공간도 마지막 원소 뒤에 함께 모여 있어서 관리 쉬움

## 6. Resizing Array보다 다른 자료구조가 더 효율적인 경우
- Queue(FIFO) 구현 (YES)
    - Resizing Array로 queue 구현하면 추가에 ~1 시간, pop(0)에 ~N 시간 소요
    - BUT Linked List 사용하면 pop()에 ~1 시간 소요
- Stack(LIFO) 구현 (NO)
    - Resizing Array로 stack 구현하면 추가에 ~1 시간, pop()에 ~1 시간 소요

---
## 학교 수업 실습 및 과제 코드
- [Merge Sort](./School_Code/MergeSort.py)