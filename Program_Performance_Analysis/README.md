# Program Performance Analysis
: 주어진 프로그램이 입력 데이터의 크기에 따라 어떤 성능을 보이는지를 예측 & 원하는 성능에 미치지 못할 때 그 이유를 찾는 것

## 1. 성능 분석
입력 데이터의 크기에 따라
### 실행 속도
### 메모리 사용량

## 2. 프로그램의 성능 표현 방법
~f(N) : 입력 데이터의 크기가 N일 때, 프로그램의 성능이 대략적으로 f(N)에 비례함
- 정확한 성능 계산보다 대략적으로 서로 다른 알고리즘 간의 차이를 큰 틀에서 빠르게 파악하는데 초점

## 3. 프로그램 성능 분석 방법(단계)

### 1> 프로그램에서 수행하는 작업의 횟수를 나타내는 수학적 모델 만들어 성능 예측
#### 1. 프로그램이 수행하는 각 작업들이 무엇인지, 이들이 몇회 수행되는지 파악
- ex1> 다음 프로그램에서의 작업 및 빈도
    ```c
    // a[], N: input data and their length
    int count = 0; // 변수 선언 및 초기화
    for (int i = 0; i < N; i++) {  // 변수 선언 & 초기화 & 변수 값 증가
        if (a[i] == 0)  // N번 비교 & 배열 접근 N회
            count++;  // 변수 값 증가
    }
    ```
    - 변수 선언 : 2회 (count, i)
    - 변수에 초기값 저장 : 2회 (count = 0, int = 0)
    - < 비교 : N + 1회
    - == 비교 : N회
    - 배열 접근 : N회
    - 변수 값 증가 : N ~ 2N회 (i++ N회, count++ 0 ~ N회)
- ex2> 다음 프로그램에서의 작업 및 빈도
    ```c
    // a[], N: input data and their length
    int count = 0; // 변수 1회 선언 및 1회 초기화
    for (int i = 0; i < N; i++) {  // 변수 1회 선언 & 1회 초기화 & 변수 값 증가
        for (int j = i + 1; j < N; j++) {  // 변수 N회 선언 & N회 초기화
            if (a[i] + a[j] == 0)  // N(N - 1) / 2번 비교 & 배열 접근 N(N - 1)회
                count++;  // 변수 값 증가
        }
    }
    ```
    - 변수 선언 : N + 2회 (count 1회, i 1회, j N회)
    - 변수에 초기값 저장 : N + 2회 (count 1회, i 1회, j N회)
    - < 비교 : (N + 1)(N + 2) / 2회 ('i < N' N + 1회, 'j < N' N(N + 1) / 2회)
    - == 비교 : N(N - 1) / 2회 (a[] 속 서로 다른 두 원소 개수 : <sub>n</sub>C<sub>2</sub>)
    - 배열 접근 : N(N - 1)회 (a[i], a[j] 각각 접근 => == 비교의 2배)
    - 변수 값 증가 : N<sup>2</sup>회 (i++ N회, j++ N(N - 1) / 2회, count++ 0 ~ N(N - 1) / 2회)

#### 2. 가장 큰 항만 남기고 나머지 작은 항(lower-order term) 제거
#### 3. 가장 큰 항에서 상수 부분 제거
N이 커질수록 상수보다 N<sup>3</sup>같은 부분들이 총 작업 횟수에 미치는 영향이 커지기 때문
- 단순화 하는 이유 : N이 커질 때 프로그램의 성능이 문제가 되는데, 특히 많은 빈도로 수행되는 작업의 가장 큰 항이 성능에 큰 영향을 미치기 때문

### 2> 프로그램 실행해보며 예측 맞는지 검증
### 3> 예측이 틀렸다면 모델 수정하며 1~3 과정 반복

- [Program Analysis Model](Program_Analysis_Model.jpg)